# Version control and collaboration with git and github

Before we begin, make sure to [install git](https://swcarpentry.github.io/git-novice/) and create an account on github (free).

[Setup your ssh key](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent)

That step is painful, but you only have to do it once ever. Don't set your key to expire quickly... or ever? ;) 

[Set up your username](https://swcarpentry.github.io/git-novice/02-setup.html)

## Lecture summary 

In this lecture, we will cover a basic workflow using git and github. This chapter is based on a lesson by Software Carpentery. For our dicussion, we will further examine best practices in science, mainly, Trisos et al. 2021 Decoloniality and anti-oppressive practices for a more ethical ecology.

### Learning objectives

- Understand the benefits of an automated version control system.
- Understand the basics of how automated version control systems work using git and github.
- Learn basic BASH commands related to being able to use git

We'll start by exploring how version control can be used
to keep track of what one person did and when.
Even if you aren't collaborating with other people,
automated version control is much better than this situation:

!["notFinal.doc" by Jorge Cham, <https://www.phdcomics.com>](fig/git/phd101212s.png){alt='Comic: a PhD student sends "FINAL.doc" to their supervisor, but after several increasingly intense and frustrating rounds of comments and revisions they end up with a file named "FINAL_rev.22.comments49.corrections.10.#@$%WHYDIDCOMETOGRADSCHOOL????.doc"'}

We've all been in this situation before: it seems unnecessary to have
multiple nearly-identical versions of the same document. Some word
processors let us deal with this a little better, such as Microsoft
Word's
[Track Changes](https://support.office.com/en-us/article/Track-changes-in-Word-197ba630-0f5f-4a8e-9a77-3712475e806a),
Google Docs' [version history](https://support.google.com/docs/answer/190843?hl=en), or
LibreOffice's [Recording and Displaying Changes](https://help.libreoffice.org/Common/Recording_and_Displaying_Changes).

Version control systems start with a base version of the document and
then record changes you make each step of the way. You can
think of it as a recording of your progress: you can rewind to start at the base
document and play back each change you made, eventually arriving at your
more recent version.

![](fig/git/play-changes.svg){alt='Changes Are Saved Sequentially'}

Once you think of changes as separate from the document itself, you
can then think about "playing back" different sets of changes on the base document, ultimately
resulting in different versions of that document. For example, two users can make independent
sets of changes on the same document.

![](fig/git/versions.svg){alt='Different Versions Can be Saved'}

Unless multiple users make changes to the same section of the document - a 
conflict - you can
incorporate two sets of changes into the same base document.

![](fig/git/merge.svg){alt='Multiple Versions Can be Merged'}

A version control system is a tool that keeps track of these changes for us, effectively creating different versions of our files. It allows us to decide which changes will be made to the next version (each record of these changes is called a [commit](../learners/reference.md#commit)), and keeps useful metadata about them. The complete history of commits for a particular project and their metadata make up a [repository](../learners/reference.md#repository).
Repositories can be kept in sync across different computers, facilitating
collaboration among different people.

### Hypothetical: Paper Writing

- Imagine you drafted an excellent paragraph for a paper you are writing, but later ruin
  it. How would you retrieve the *excellent* version of your conclusion? Is it even possible?

- Imagine you have 5 co-authors. How would you manage the changes and comments
  they make to your paper?  If you use LibreOffice Writer or Microsoft Word, what happens if
  you accept changes made using the `Track Changes` option? Do you have a
  history of those changes?


### Solution

- Recovering the excellent version is only possible if you created a copy
  of the old version of the paper. The danger of losing good versions
  often leads to the problematic workflow illustrated in the PhD Comics
  cartoon at the top of this page.

- Collaborative writing with traditional word processors is cumbersome.
  Either every collaborator has to work on a document sequentially
  (slowing down the process of writing), or you have to send out a
  version to all collaborators and manually merge their comments into
  your document. The 'track changes' or 'record changes' option can
  highlight changes for you and simplifies merging, but as soon as you
  accept changes you will lose their history. You will then no longer
  know who suggested that change, why it was suggested, or when it was
  merged into the rest of the document. Even online word processors like
  Google Docs or Microsoft Office Online do not fully resolve these
  problems.
  
  
- Version control is like an unlimited 'undo'.
- Version control also allows many people to work in parallel.

### Why Use Git and GitHub?

**Git** is a version control system — a “time machine” for code and text. It helps you:

- Track who changed what and when.
- Roll back to earlier versions if something breaks.
- Work safely on features/experiments without touching the main project.

**GitHub** is a cloud host for Git repositories. It makes teamwork easier by offering:

- Shared remote repos (backup + collaboration).
- Pull requests & code review.
- Issues, wiki, and automation.

---

### A Simple Two-Person Git Workflow

Suppose **Lauren** and **Rebecca** collaborate on the same project.

1. **Setup**
   - Lauren creates a repository (on GitHub, or locally for this demo) and pushes an initial commit.
   - Rebecca *clones* it to his computer.

2. **Daily Cycle (repeat)**
   - `git pull` to get the latest work.
   - Edit files.
   - `git add` to stage changes.
   - `git commit -m "message"` to record changes locally.
   - `git push` to share with collaborators.

**Mnemonic:** *pull → edit → add → commit → push*.

---

### Five Essential Git Commands

### 1) `git status`
Shows what changed and whether those changes are staged (ready to commit).
```bash
git status
```

**Use it:** Frequently — before/after edits, and before committing.

### 2) `git add`
Stages file(s) so they’re included in the next commit.
```bash
git add README.md
# or stage everything new/modified:
git add .
```
**Use it:** After editing/creating files you want to include in the next commit.

### 3) `git commit -m "message"`
Records a snapshot of the staged changes in the local repo.
```bash
git commit -m "feat: Created a new function that cleans the species. names and summarizes the number of times each occurs."
```

**Use it:** After staging with `git add` to save a meaningful unit of work. Use complete sentences and enough detail where you and your partner will understand exactly what you did.

Good/conventional commit messages: Commit messages should start with a "tag" of what type of commit is it (see below), than a brief (\<50 characters) statement about the changes made in the commit. Generally, the message should complete the sentence "If applied, this commit will" <commit message here>.

If you want to go into more detail, add a blank line between the summary line and your additional notes. Use this additional space to explain why you made changes and/or what their impact will be.

Feat– feature
Fix– bug fixes
Docs– changes to the documentation like README
Style– style or formatting change 
Perf – improves code performance
Test– test a feature

Best practices: [Conventional commits](https://gist.github.com/Zekfad/f51cb06ac76e2457f11c80ed705c95a3)

### 4) `git push`
Uploads your local commits to the remote (e.g., GitHub).
```bash
git push
```
**Use it:** After committing, to share your changes with collaborators.

### 5) `git pull`
Downloads and integrates changes from the remote into your local branch.
```bash
git pull
```
**Use it:** Before you start work (and also when Git tells you you’re behind).

---

### git command summary

- `git status` tells you what’s changed and what will be committed.
- `git add` stages the change; `git commit -m "…" ` records it locally.
- `git push` shares your commits to a remote; `git pull` brings remote changes to you.
- A consistent habit — **pull → edit → add → commit → push** — keeps collaborators in sync.

### I cannot push my commit!? 

Likely because: 

- Multiple people made changes to the same file. 
- You forgot to pull before starting to work. 
- For this class, though this is not a great practice, save you work somewhere outside of the repo. Re-clone the repo. Continue as before. 

**More advanced git** 

- Create branches for each person to work on, merge the branches with the main branch 
- You can go back to previous commits (a important component of git). 

### Introducing the shell

**Getting Started: the Prompt**

When the shell is first opened, you are presented with a prompt, which means the shell is waiting for input.

Example prompt:

```bash
$
```

Type a command after the prompt, then press Enter to run it.

**Prompt**

- Do **not** type the `$` itself — only the command that follows.
- After you type a command, press Enter to execute it.
- The prompt is followed by a cursor (often a blinking block, underscore, or pipe) that shows where your typing will appear.
- Your prompt symbol may differ depending on configuration.

**Prompt name**

- Your prompt might include your username and the computer (host) name before the `$`.
- Example:
  
```bash
lponisio@UO-2007086 $
```

**File systems**

- The part of the operating system responsible for managing files and directories is called the **file system**.
- It organizes data into:
  - **files**, which hold information
  - **directories** (also called "folders"), which hold files or other directories
- We’ll use shell commands to create, inspect, rename, and delete files and directories.

**`pwd`: print working directory**

Your "current working directory" is where you are right now.  
Commands mostly read and write files in the current working directory (“here”), so knowing where you are matters.

Use `pwd` ("print working directory") to show where you are:

```bash
$ pwd
/Users/lponisio
```

This path is your home directory.

**Home directory variation**

- The home directory path looks different on different operating systems.
  - macOS: `/Users/<name>`
  - Linux: `/home/<name>`
  - Windows: `C:\Users\<name>` (or sometimes `C:\Documents and Settings\<name>` on older Windows)
- Examples in this lesson use macOS-style output. Linux and Windows output may differ slightly but are generally similar.

**Directories and the root directory**

- We know that our current working directory `/Users/lponisio` is stored inside `/Users` because `/Users` is the first part of its name.
- `/Users` is stored inside the root directory `/` because its name begins with `/`.
- `/` is the **root directory**, i.e. the top of the entire filesystem.

**`ls`: list directory contents**

We can see what's in the current directory with `ls`:

```bash
$ ls
Applications Documents Library Music Public
Desktop      Downloads Movies  Pictures
```

To classify the output, use the `-F` option:

```bash
$ ls -F
Applications/ Documents/ Library/ Music/ Public/
Desktop/      Downloads/ Movies/  Pictures/
```

`ls -F` markers:
- a trailing `/` means "this is a directory"
- `@` means a link
- `*` means an executable

Many shells also colorize output to distinguish files and directories.

**Clearing your terminal**

- If your screen gets cluttered, run:

```bash
clear
```

- You can still access previous commands using ↑ and ↓ to move through history, or by scrolling.

**Exploring other directories with `cd` **

Use `cd <directory>` to change your working directory.  
This is like double-clicking a folder in a graphical interface.

Example navigation into nested folders:

```bash
$ cd Desktop
$ cd amazing_science
$ cd data
```

Check where you ended up:

```bash
$ pwd
Desktop/amazing_science/data
```

List what’s there:

```bash
$ ls -F
life_changing_data.csv
```

`cd ..` moves you *up* one directory level (to the parent directory).

** `pwd`, `ls`, and `cd` together**

- These three (`pwd`, `ls`, `cd`) are the basic navigation tools.
- `cd` with no argument returns you to your home directory:

```bash
$ cd
$ pwd
/Users/lponisio
```

- You can jump multiple levels at once:

```bash
$ cd Desktop/amazing_science/data
```

- Many shell commands do not print anything when they succeed.

** Path shortcuts: `..`, `.`, `~`, and `-` **

- `..` means "the parent directory" (the directory containing this one).
- `.` means "the current directory".
- `~` at the start of a path means "the current user's home directory".
  - For user `lponisio`, `~/data` is equivalent to `/Users/lponisio/data`.
- `cd -` jumps back to your previous directory (quick toggle).
  - `cd ..` brings you "up"
  - `cd -` brings you "back"

** General syntax of a shell command**

General pattern:

```bash
command [options] [arguments]
```

Example:

```bash
$ ls -F /
```

- `ls` is the command.
- `-F` is an option (short options start with `-`, long options start with `--`).
- `/` is an argument (what to operate on).

Notes:
- You can provide multiple options and multiple arguments.
- Spaces matter: `ls -F` is not the same as `ls-F`.
- Case matters: `-s` is different from `-S`.

** Summary **

- The file system manages information on disk.
- Information is stored in **files**, which are stored in **directories** (folders).
- Directories can store other directories, forming a *directory tree*.
- `pwd` prints your current working directory.
- `ls [path]` lists a specific file or directory; plain `ls` lists the current working directory.
- `cd [path]` changes the current working directory.
- Most commands take options that begin with `-`.
- Directory names in a path are separated with `/` on Unix/macOS and `\` on Windows.
- `/` alone is the root directory of the whole file system.
- An **absolute path** starts at `/`.  
- A **relative path** starts from where you are now.
- `.` means "the current directory"; `..` means "the directory above the current one".


```{r child="readings/05-reading.Rmd", echo=FALSE, error=TRUE}
```

```{r child="labs/05-lab-version_control_student.Rmd", echo=FALSE, error=TRUE}
```
